Buna seara!

Aici este partea de optional din laboratorul 11.

Pentru primul punct al laboratorului, am creat 2 noi clase: FriendController si FriendService. In FriendController, am facut rutele operatiilor pentru relatiile de prietenie:
"/friends/all" returneaza lista tuturor prieteniilor create (de forma pk care este id-ul unic/primary key pentru fiecare prietenie, pId care este id-ul persoanei care a 
"initiat" prietenie si fId care reprezinta id-ul persoanei cu care persoana identificata prin pId vrea sa se imprieteneasca), "/friends/friendships" returneaza lista tuturor
prieteniilor in formatul pNume, fNume ce reprezinta faptul ca persoana cu numele pNume s-a imprietenit cu persoana cu numele fNume, "/friends/add" creeaza o prietenie intre persoana cu id-ul dat ca parametru de utilizator pId si cea cu id-ul specificat fId si "/friends/delete" sterge din baza de date prietenie cu primary key-ul pk ce este specificat de catre user. In FriendService, am implementat toate aceste operatii (in controller avem doar rutele si apelurile functiilor din serviciu, iar in serviciu avem implementarea efectiva a tuturor operatiilor necesare). Pe langa aceste 2 clase, am mai facut o entitate care se numeste Friend si care modeleaza tabelul de prietenii din baza de date (contine pk ce este primary key-ul fiecarei prietenii, pId ce reprezinta id-ul persoanei care initiaza prietenia si fId care este id-ul persoanei cu care prima persoana vrea sa se imprieteneasca) si un repository numir FriendRepository care ne ajuta sa stabilim legatura cu baza de date create in postgres.

Pentru al doilea punct, am adaugat 2 noi rute in FriendController, si anume "/friends/popular" si "/friends/allPopular". In prima ruta, avem ca parametru un integer k ce reprezinta numarul de persoane populare pe care le doreste utilizatorul si functia corespunzatoare din FriendService (getMostPopular(int k)) genereaza cele mai populare/conectate k persoane din reteau sociala (din lista de prieteni si de persoane din retea, am facut un graf neorientat si practic am impartit acest graf pe componente conexe: pentru fiecare varf nevizitat din graf am facut un dfs incepand din el si am retinut pe parcurs varfurile pe care le vizitez in timpul dfs-ului intr-un connected, iar la sfarsit in connected am ordinea tuturor varfurilor => primele k cele mai populare persoane sunt primele k varfuri din connected deoarece impartind graful pe componente conexe, vad care sunt varfurile care au cele mai multe muchii => sunt cele mai populare persoane; pentru graf, am luat id-ul fiecarei persoane dintr-o prietenie => daca id1 si id2 sunt prieteni, atunci in graf vom avea muchiile graph[id1][id2] = graph[id2][id1] = true. La finalul acestei functii din serviciu, daca k > nr (nr. total de persoane din reteaua sociala), atunci returnez un mesaj in care spun ca utilizatorul trebuie sa aleaga un k mai mic, iar daca k <= nr, atunci returnez un mesaj in care ii spun utilizatorului ca acea lista de persoane populare a fost generata. Pe ruta "/friends/allPopular" apelez functia corespunzatoare din FriendService si doar returnez lista primeler k persoane populare din reteaua sociala.

Pentru al treilea punct din laborator, am integrat proiectul springboot prin Rest Template. Astfel, in primul rand, am adaugat o noua variabila privata la clasa Client|Thread, si anume res care este de tip RestTemplate si apoi, la operatiile unde aveam nevoie sa fac de baza de date (register si friend) am folosit res.getForObject(), unde ca url am folosit link-ul care ar “declansa” operatia respectiva (de exemplu, pentru a adauga un nou user in baza de date, url-ul este “http://localhost:8090/users/{name}”, unde name este un parametru ce reprezinta numele noului utilizator), functionReturnType.class (functionReturnType este inlocuit de tipul de return al functiei => pentru exemplul precedent, vom aveam String.class), dupa care urmeaza eventualii parametri, daca sunt (de exemplu, pentru a adauga o noua prietenie, trebuie sa dam la sfarsit pId si fId ca totul sa mearga cum trebuie). Pe langa asta, am adaugat o noua functionalitate a retelei sociale, si anume “top k”, care returneaza un String care ori este mesajul ca parametrul k ales este prea mic si trebuie schimbat, ori returneaza daca utilizatorul se afla in primii k cei mai populari utilizatori.

Pentru ultimul punct, in FriendController, la functia prin care putem sterge o prietenie, am adaugat un mod prin care putem sa vedem daca avem o exceptie (utilizatorul pe care vrem sa-l stergem nu exista, de exemplu). In primul rand, am pus un bloc try - catch. In try, am pus operatia de stergere si mesajul returnat daca totul merge okay, iar in catch am luat un ResponseEntity<> cu parametrul HttpStatus.INTERNAL_SERVER_ERROR si la final returnez mesajul de eroare. Acesta este reprezentat in alta clasa, ExceptionHandler, care este de tip @RestControllerAdvice si unde avem o anotare @ResponseStatus ce are valoarea parametrului http status de mai sus si functia care are “grija” de aceasta eroare facand un mesaj de eroare sugestiv pentru utilizator pentru ca acesta sa inteleaga ce nu merge bine. 


O seara frumoasa!
