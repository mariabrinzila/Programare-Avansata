Buna seara!

Aici este partea de optional din laboratorul 11.

Pentru primul punct al laboratorului, am creat 2 noi clase: FriendController si FriendService. In FriendController, am facut rutele operatiilor pentru relatiile de prietenie:
"/friends/all" returneaza lista tuturor prieteniilor create (de forma pk care este id-ul unic/primary key pentru fiecare prietenie, pId care este id-ul persoanei care a 
"initiat" prietenie si fId care reprezinta id-ul persoanei cu care persoana identificata prin pId vrea sa se imprieteneasca), "/friends/friendships" returneaza lista tuturor
prieteniilor in formatul pNume, fNume ce reprezinta faptul ca persoana cu numele pNume s-a imprietenit cu persoana cu numele fNume, "/friends/add" creeaza o prietenie intre persoana cu id-ul dat ca parametru de utilizator pId si cea cu id-ul specificat fId si "/friends/delete" sterge din baza de date prietenie cu primary key-ul pk ce este specificat de catre user. In FriendService, am implementat toate aceste operatii (in controller avem doar rutele si apelurile functiilor din serviciu, iar in serviciu avem implementarea efectiva a tuturor operatiilor necesare). Pe langa aceste 2 clase, am mai facut o entitate care se numeste Friend si care modeleaza tabelul de prietenii din baza de date (contine pk ce este primary key-ul fiecarei prietenii, pId ce reprezinta id-ul persoanei care initiaza prietenia si fId care este id-ul persoanei cu care prima persoana vrea sa se imprieteneasca) si un repository numir FriendRepository care ne ajuta sa stabilim legatura cu baza de date create in postgres.

Pentru al doilea punct, am adaugat 2 noi rute in FriendController, si anume "/friends/popular" si "/friends/allPopular". In prima ruta, avem ca parametru un integer k ce reprezinta numarul de persoane populare pe care le doreste utilizatorul si functia corespunzatoare din FriendService (getMostPopular(int k)) genereaza cele mai populare/conectate k persoane din reteau sociala (din lista de prieteni si de persoane din retea, am facut un graf neorientat si practic am impartit acest graf pe componente conexe: pentru fiecare varf nevizitat din graf am facut un dfs incepand din el si am retinut pe parcurs varfurile pe care le vizitez in timpul dfs-ului intr-un connected, iar la sfarsit in connected am ordinea tuturor varfurilor => primele k cele mai populare persoane sunt primele k varfuri din connected deoarece impartind graful pe componente conexe, vad care sunt varfurile care au cele mai multe muchii => sunt cele mai populare persoane; pentru graf, am luat id-ul fiecarei persoane dintr-o prietenie => daca id1 si id2 sunt prieteni, atunci in graf vom avea muchiile graph[id1][id2] = graph[id2][id1] = true. La finalul acestei functii din serviciu, daca k > nr (nr. total de persoane din reteaua sociala), atunci returnez un mesaj in care spun ca utilizatorul trebuie sa aleaga un k mai mic, iar daca k <= nr, atunci returnez un mesaj in care ii spun utilizatorului ca acea lista de persoane populare a fost generata. 

O seara frumoasa!
